{"title":"Building Neural Network from scratch","markdown":{"yaml":{"title":"Building Neural Network from scratch","author":"Aayush Agrawal","date":"2018-06-03","categories":["Machine Learning","Deep Learning"],"image":"https://raw.githubusercontent.com/aayushmnit/Deep_learning_explorations/master/1_MLP_from_scratch/single_layer_mlp.png"},"headingText":"What is a neural network?","containsRefs":false,"markdown":"\nIn this notebook, we are going to build a neural network(multilayer perceptron) using numpy and successfully train it to recognize digits in the image. Deep learning is a vast topic, but we got to start somewhere, so let's start with the very basics of a neural network which is Multilayer Perceptron. You can find the same blog in notebook version [here](https://github.com/aayushmnit/Deep_learning_explorations/tree/master/1_MLP_from_scratch).\n\nA neural network is a type of machine learning model which is inspired by our neurons in the brain where many neurons are connected with many other neurons to translate an input to an output (simple right?). Mostly we can look at any machine learning model and think of it as a function which takes an input and produces the desired output; it's the same with a neural network.\n\n## What is a Multi layer perceptron?\n\nMulti-layer perceptron is a type of network where multiple layers of a group of perceptron are stacked together to make a model. Before we jump into the concept of a layer and multiple perceptrons, let's start with the building block of this network which is a perceptron. Think of perceptron/neuron as a linear model which takes multiple inputs and produce an output. In our case perceptron is a linear model which takes a bunch of inputs multiply them with weights and add a bias term to generate an output.<br/>\n<img src =\"eq_perceptron.png\" align='center'> <br/>\n<img src=\"https://raw.githubusercontent.com/aayushmnit/Deep_learning_explorations/master/1_MLP_from_scratch/perceptron.png\" align='center'>\n<center>Fig 1: Perceptron image</center> <br/>\n<div align='right'>Image credit=https://commons.wikimedia.org/wiki/File:Perceptron.png/</div>\n\nNow, if we stack a bunch of these perceptrons together, it becomes a hidden layer which is also known as a Dense layer in modern deep learning terminology. <br/>\n__Dense layer,__ <img src =\"eq_dense.png\"> <br/>\n*Note that bias term is now a vector and W is a weight matrix* <br/>\n<img src=\"https://raw.githubusercontent.com/aayushmnit/Deep_learning_explorations/master/1_MLP_from_scratch/single_layer_mlp.png\" align ='center'>\n<center>Fig: Single dense layer perceptron network</center> <br/>\n<div align='right'>Image credit=http://www.texample.net/tikz/examples/neural-network/</div>\n\nNow we understand dense layer let's add a bunch of them, and that network becomes a multi-layer perceptron network.\n\n<img src=\"https://raw.githubusercontent.com/aayushmnit/Deep_learning_explorations/master/1_MLP_from_scratch/multi_layer_mlp.png\" align ='center'>\n<center>Fig: Multi layer perceptron network</center> <br/>\n<div align='right'>Image credit=http://pubs.sciepub.com/ajmm/3/3/1/figure/2s</div>    \n\nIf you have noticed our dense layer, only have linear functions, and any combination of linear function only results in the linear output. As we want our MLP to be flexible and learn non-linear decision boundaries, we also need to introduce non-linearity into the network. We achieve the task of introducing non-linearity by adding activation function. There are various kinds of activation function which can be used, but we will be implementing Rectified Linear Units(ReLu) which is one of the popular activation function. ReLU function is a simple function which is zero for any input value below zero and the same value for values greater than zero. <br/>\n__ReLU function__ <img src=\"eq_relu.png\">\n<br/>\nNow, we understand dense layer and also understand the purpose of activation function, the only thing left is training the network. For training a neural network we need to have a loss function and every layer should have a __feed-forward loop__ and __backpropagation loop__. Feedforward loop takes an input and generates output for making a prediction and backpropagation loop helps in training the model by adjusting weights in the layer to lower the output loss. In backpropagation, the weight update is done by using backpropagated gradients using the chain rule and optimized using an optimization algorithm. In our case, we will be using SGD(stochastic gradient descent). If you don't understand the concept of gradient weight updates and SGD, I recommend you to watch [week 1 of Machine learning by Andrew NG lectures](https://www.coursera.org/ml).\n\nSo, to summarize a neural network needs few building blocks\n\n- __Dense layer__ - a fully-connected layer, <img src=\"eq_dense.png\">\n- __ReLU layer__ (or any other activation function to introduce non-linearity)\n- __Loss function__ - (crossentropy in case of multi-class classification problem)\n- __Backprop algorithm__ - a stochastic gradient descent with backpropageted gradients\n\nLet's approach them one at a time.\n\n## Coding Starts here:\n\nLet's start by importing some libraires required for creating our neural network.\n\n\n```python\nfrom __future__ import print_function\nimport numpy as np ## For numerical python\nnp.random.seed(42)\n```\n\nEvery layer will have a forward pass and backpass implementation. Let's create a main class layer which can do a forward pass *.forward()* and Backward pass *.backward().*\n\n\n```python\nclass Layer:\n    \n    #A building block. Each layer is capable of performing two things:\n\n    #- Process input to get output:           output = layer.forward(input)\n    \n    #- Propagate gradients through itself:    grad_input = layer.backward(input, grad_output)\n    \n    #Some layers also have learnable parameters which they update during layer.backward.\n    \n    def __init__(self):\n        # Here we can initialize layer parameters (if any) and auxiliary stuff.\n        # A dummy layer does nothing\n        pass\n    \n    def forward(self, input):\n        # Takes input data of shape [batch, input_units], returns output data [batch, output_units]\n        \n        # A dummy layer just returns whatever it gets as input.\n        return input\n\n    def backward(self, input, grad_output):\n        # Performs a backpropagation step through the layer, with respect to the given input.\n        \n        # To compute loss gradients w.r.t input, we need to apply chain rule (backprop):\n        \n        # d loss / d x  = (d loss / d layer) * (d layer / d x)\n        \n        # Luckily, we already receive d loss / d layer as input, so you only need to multiply it by d layer / d x.\n        \n        # If our layer has parameters (e.g. dense layer), we also need to update them here using d loss / d layer\n        \n        # The gradient of a dummy layer is precisely grad_output, but we'll write it more explicitly\n        num_units = input.shape[1]\n        \n        d_layer_d_input = np.eye(num_units)\n        \n        return np.dot(grad_output, d_layer_d_input) # chain rule\n```\n\n### Nonlinearity ReLU layer\n\nThis is the simplest layer you can get: it simply applies a nonlinearity to each element of your network.\n\n\n```python\nclass ReLU(Layer):\n    def __init__(self):\n        # ReLU layer simply applies elementwise rectified linear unit to all inputs\n        pass\n    \n    def forward(self, input):\n        # Apply elementwise ReLU to [batch, input_units] matrix\n        relu_forward = np.maximum(0,input)\n        return relu_forward\n    \n    def backward(self, input, grad_output):\n        # Compute gradient of loss w.r.t. ReLU input\n        relu_grad = input > 0\n        return grad_output*relu_grad \n```\n\n### Dense layer\n\nNow let's build something more complicated. Unlike nonlinearity, a dense layer actually has something to learn.\n\nA dense layer applies affine transformation. In a vectorized form, it can be described as:<br/>\n<img src=\"eq_dense.png\">\n\nWhere \n* X is an object-feature matrix of shape [batch_size, num_features],\n* W is a weight matrix [num_features, num_outputs] \n* and b is a vector of num_outputs biases.\n\nBoth W and b are initialized during layer creation and updated each time backward is called. Note that we are using **Xavier initialization** which is a trick to train our model to converge faster [read more](http://andyljones.tumblr.com/post/110998971763/an-explanation-of-xavier-initialization). Instead of initializing our weights with small numbers which are distributed randomly we initialize our weights with mean zero and variance of 2/(number of inputs + number of outputs)\n\n\n```python\nclass Dense(Layer):\n    def __init__(self, input_units, output_units, learning_rate=0.1):\n        # A dense layer is a layer which performs a learned affine transformation:\n        # f(x) = <W*x> + b\n        \n        self.learning_rate = learning_rate\n        self.weights = np.random.normal(loc=0.0, \n                                        scale = np.sqrt(2/(input_units+output_units)), \n                                        size = (input_units,output_units))\n        self.biases = np.zeros(output_units)\n        \n    def forward(self,input):\n        # Perform an affine transformation:\n        # f(x) = <W*x> + b\n        \n        # input shape: [batch, input_units]\n        # output shape: [batch, output units]\n        \n        return np.dot(input,self.weights) + self.biases\n    \n    def backward(self,input,grad_output):\n        # compute d f / d x = d f / d dense * d dense / d x\n        # where d dense/ d x = weights transposed\n        grad_input = np.dot(grad_output, self.weights.T)\n        \n        # compute gradient w.r.t. weights and biases\n        grad_weights = np.dot(input.T, grad_output)\n        grad_biases = grad_output.mean(axis=0)*input.shape[0]\n        \n        assert grad_weights.shape == self.weights.shape and grad_biases.shape == self.biases.shape\n        \n        # Here we perform a stochastic gradient descent step. \n        self.weights = self.weights - self.learning_rate * grad_weights\n        self.biases = self.biases - self.learning_rate * grad_biases\n        \n        return grad_input\n```\n\n### The loss function\n\nSince we want to predict probabilities, it would be logical for us to define softmax nonlinearity on top of our network and compute loss given predicted probabilities. However, there is a better way to do so.\n\nIf we write down the expression for crossentropy as a function of softmax logits (a), you'll see: <br/>\n\n<img src=\"loss_1.png\">\n<br/>\nIf we take a closer look, we'll see that it can be rewritten as: <br/>\n\n<img src=\"loss_2.png\">\n<br/>\nIt's called Log-softmax and it's better than naive log(softmax(a)) in all aspects:\n* Better numerical stability\n* Easier to get derivative right\n* Marginally faster to compute\n\nSo why not just use log-softmax throughout our computation and never actually bother to estimate probabilities.\n\n\n```python\ndef softmax_crossentropy_with_logits(logits,reference_answers):\n    # Compute crossentropy from logits[batch,n_classes] and ids of correct answers\n    logits_for_answers = logits[np.arange(len(logits)),reference_answers]\n    \n    xentropy = - logits_for_answers + np.log(np.sum(np.exp(logits),axis=-1))\n    \n    return xentropy\n\ndef grad_softmax_crossentropy_with_logits(logits,reference_answers):\n    # Compute crossentropy gradient from logits[batch,n_classes] and ids of correct answers\n    ones_for_answers = np.zeros_like(logits)\n    ones_for_answers[np.arange(len(logits)),reference_answers] = 1\n    \n    softmax = np.exp(logits) / np.exp(logits).sum(axis=-1,keepdims=True)\n    \n    return (- ones_for_answers + softmax) / logits.shape[0]\n```\n\n### Full network\n\nNow let's combine what we've just built into a working neural network. As I have told earlier, we are going to use MNIST data of handwritten digit for our example. Fortunately, Keras already have it in the numpy array format, so let's import it!.\n\n\n```python\nimport keras\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\ndef load_dataset(flatten=False):\n    (X_train, y_train), (X_test, y_test) = keras.datasets.mnist.load_data()\n\n    # normalize x\n    X_train = X_train.astype(float) / 255.\n    X_test = X_test.astype(float) / 255.\n\n    # we reserve the last 10000 training examples for validation\n    X_train, X_val = X_train[:-10000], X_train[-10000:]\n    y_train, y_val = y_train[:-10000], y_train[-10000:]\n\n    if flatten:\n        X_train = X_train.reshape([X_train.shape[0], -1])\n        X_val = X_val.reshape([X_val.shape[0], -1])\n        X_test = X_test.reshape([X_test.shape[0], -1])\n\n    return X_train, y_train, X_val, y_val, X_test, y_test\n\nX_train, y_train, X_val, y_val, X_test, y_test = load_dataset(flatten=True)\n\n## Let's look at some example\nplt.figure(figsize=[6,6])\nfor i in range(4):\n    plt.subplot(2,2,i+1)\n    plt.title(\"Label: %i\"%y_train[i])\n    plt.imshow(X_train[i].reshape([28,28]),cmap='gray');\n```\n\n<img src=\"output_20_1.png\" align ='center'>\n\n\n\nWe'll define network as a list of layers, each applied on top of previous one. In this setting, computing predictions and training becomes trivial.\n\n\n```python\nnetwork = []\nnetwork.append(Dense(X_train.shape[1],100))\nnetwork.append(ReLU())\nnetwork.append(Dense(100,200))\nnetwork.append(ReLU())\nnetwork.append(Dense(200,10))\n```\n\n\n```python\ndef forward(network, X):\n    # Compute activations of all network layers by applying them sequentially.\n    # Return a list of activations for each layer. \n    \n    activations = []\n    input = X\n\n    # Looping through each layer\n    for l in network:\n        activations.append(l.forward(input))\n        # Updating input to last layer output\n        input = activations[-1]\n    \n    assert len(activations) == len(network)\n    return activations\n\ndef predict(network,X):\n    # Compute network predictions. Returning indices of largest Logit probability\n\n    logits = forward(network,X)[-1]\n    return logits.argmax(axis=-1)\n\ndef train(network,X,y):\n    # Train our network on a given batch of X and y.\n    # We first need to run forward to get all layer activations.\n    # Then we can run layer.backward going from last to first layer.\n    # After we have called backward for all layers, all Dense layers have already made one gradient step.\n    \n    \n    # Get the layer activations\n    layer_activations = forward(network,X)\n    layer_inputs = [X]+layer_activations  #layer_input[i] is an input for network[i]\n    logits = layer_activations[-1]\n    \n    # Compute the loss and the initial gradient\n    loss = softmax_crossentropy_with_logits(logits,y)\n    loss_grad = grad_softmax_crossentropy_with_logits(logits,y)\n    \n    # Propagate gradients through the network\n    # Reverse propogation as this is backprop\n    for layer_index in range(len(network))[::-1]:\n        layer = network[layer_index]\n        \n        loss_grad = layer.backward(layer_inputs[layer_index],loss_grad) #grad w.r.t. input, also weight updates\n        \n    return np.mean(loss)\n```\n\n### Training loop\n\nWe split data into minibatches, feed each such minibatch into the network and update weights. This training method is called a mini-batch stochastic gradient descent.\n\n\n```python\nfrom tqdm import trange\ndef iterate_minibatches(inputs, targets, batchsize, shuffle=False):\n    assert len(inputs) == len(targets)\n    if shuffle:\n        indices = np.random.permutation(len(inputs))\n    for start_idx in trange(0, len(inputs) - batchsize + 1, batchsize):\n        if shuffle:\n            excerpt = indices[start_idx:start_idx + batchsize]\n        else:\n            excerpt = slice(start_idx, start_idx + batchsize)\n        yield inputs[excerpt], targets[excerpt]\n```\n\n\n```python\nfrom IPython.display import clear_output\ntrain_log = []\nval_log = []\n```\n\n\n```python\nfor epoch in range(25):\n\n    for x_batch,y_batch in iterate_minibatches(X_train,y_train,batchsize=32,shuffle=True):\n        train(network,x_batch,y_batch)\n    \n    train_log.append(np.mean(predict(network,X_train)==y_train))\n    val_log.append(np.mean(predict(network,X_val)==y_val))\n    \n    clear_output()\n    print(\"Epoch\",epoch)\n    print(\"Train accuracy:\",train_log[-1])\n    print(\"Val accuracy:\",val_log[-1])\n    plt.plot(train_log,label='train accuracy')\n    plt.plot(val_log,label='val accuracy')\n    plt.legend(loc='best')\n    plt.grid()\n    plt.show()\n    \n```\n\n    Epoch 24\n    Train accuracy: 1.0\n    Val accuracy: 0.9809\n    \n\n\n<img src=\"output_27_1.png\" align ='center'>\n\n\nAs we can see we have successfully trained a MLP which was purely written in numpy with high validation accuracy!\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.226","theme":{"light":"sandstone","dark":"cyborg"},"mainfont":"Roboto","comments":{"utterances":{"repo":"aayushmnit/blogComments"}},"title":"Building Neural Network from scratch","author":"Aayush Agrawal","date":"2018-06-03","categories":["Machine Learning","Deep Learning"],"image":"https://raw.githubusercontent.com/aayushmnit/Deep_learning_explorations/master/1_MLP_from_scratch/single_layer_mlp.png"},"extensions":{"book":{"multiFile":true}}}}}